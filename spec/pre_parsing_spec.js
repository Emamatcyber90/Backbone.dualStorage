// Generated by CoffeeScript 1.9.2
(function() {
  var Collection, Model, backboneSync, dualSync, localStorage, localSync, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  backboneSync = window.backboneSync, localSync = window.localSync, dualSync = window.dualSync, localStorage = window.localStorage;

  ref = {}, Collection = ref.Collection, Model = ref.Model;

  describe('pre-parsing', function() {
    this.timeout(100);
    beforeEach(function() {
      localStorage.clear();
      Model = (function(superClass) {
        extend(Model, superClass);

        function Model() {
          return Model.__super__.constructor.apply(this, arguments);
        }

        Model.prototype.idAttribute = '_id';

        Model.prototype.urlRoot = 'things/';

        return Model;

      })(Backbone.Model);
      return Collection = (function(superClass) {
        extend(Collection, superClass);

        function Collection() {
          return Collection.__super__.constructor.apply(this, arguments);
        }

        Collection.prototype.model = Model;

        Collection.prototype.url = Model.prototype.urlRoot;

        return Collection;

      })(Backbone.Collection);
    });
    beforeEach(function() {
      Model.prototype.parse = function(response) {
        var ref1;
        response.phrase = (ref1 = response.phrase) != null ? ref1.replace(/!/, ' parseWasHere') : void 0;
        return response;
      };
      Model.prototype.parseBeforeLocalSave = function(unformattedReponse) {
        return {
          _id: 1,
          phrase: unformattedReponse
        };
      };
      Collection.prototype.parse = function(response) {
        var i, item, j, len, results;
        i = 0;
        results = [];
        for (j = 0, len = response.length; j < len; j++) {
          item = response[j];
          _.extend(item, {
            order: i++
          });
          results.push(item);
        }
        return results;
      };
      return Collection.prototype.parseBeforeLocalSave = function(response) {
        return _.map(response, function(item) {
          return {
            _id: item
          };
        });
      };
    });
    describe('Model.parseBeforeLocalSave', function() {
      return describe('on fetch', function() {
        return it('transforms the response into a hash of attributes with an id', function(done) {
          var fetched, model;
          model = new Model;
          fetched = $.Deferred();
          model.fetch({
            serverResponse: 'Hi!!',
            success: function() {
              return fetched.resolve();
            }
          });
          return fetched.done(function() {
            expect(model.id).to.equal(1);
            expect(model.get('phrase')).not.to.be["null"];
            return done();
          });
        });
      });
    });
    describe('Model.parse', function() {
      return describe('when used alongside parseBeforeLocalSave', function() {
        it('modifies attributes in the response to fit an API response to the backbone model', function(done) {
          var fetched, model;
          model = new Model;
          fetched = $.Deferred();
          model.fetch({
            serverResponse: 'Hi!',
            success: function() {
              return fetched.resolve();
            }
          });
          return fetched.done(function() {
            expect(model.get('phrase')).to.equal('Hi parseWasHere');
            return done();
          });
        });
        return it('bug: parse should not be called twice on the response');
      });
    });
    describe('Collection.parseBeforeLocalSave', function() {
      return describe('on fetch', function() {
        return it('transforms the response into an array of hash attributes with an id', function(done) {
          var collection, fetched;
          collection = new Collection;
          fetched = $.Deferred();
          collection.fetch({
            serverResponse: ['a', 'b'],
            success: function() {
              return fetched.resolve();
            }
          });
          return fetched.done(function() {
            expect(collection.get('a')).not.to.be["null"];
            expect(collection.get('b')).not.to.be["null"];
            return done();
          });
        });
      });
    });
    return describe('Collection.parse', function() {
      return describe('when used alongside parseBeforeLocalSave', function() {
        return it('modifies objects in the response to fit an API response to the backbone model', function(done) {
          var collection, fetched;
          collection = new Collection;
          fetched = $.Deferred();
          collection.fetch({
            serverResponse: ['a', 'b'],
            success: function() {
              return fetched.resolve();
            }
          });
          return fetched.done(function() {
            expect(collection.get('a').get('order')).to.equal(0);
            expect(collection.get('b').get('order')).to.equal(1);
            return done();
          });
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=pre_parsing_spec.js.map
