// Generated by CoffeeScript 1.9.2
(function() {
  var Collection, Model, backboneSync, dualSync, localStorage, localSync, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  backboneSync = window.backboneSync, localSync = window.localSync, dualSync = window.dualSync, localStorage = window.localStorage;

  ref = {}, Collection = ref.Collection, Model = ref.Model;

  describe('callbacks', function() {
    this.timeout(100);
    beforeEach(function() {
      localStorage.clear();
      Model = (function(superClass) {
        extend(Model, superClass);

        function Model() {
          return Model.__super__.constructor.apply(this, arguments);
        }

        Model.prototype.idAttribute = '_id';

        Model.prototype.urlRoot = 'things/';

        return Model;

      })(Backbone.Model);
      return Collection = (function(superClass) {
        extend(Collection, superClass);

        function Collection() {
          return Collection.__super__.constructor.apply(this, arguments);
        }

        Collection.prototype.model = Model;

        Collection.prototype.url = Model.prototype.urlRoot;

        return Collection;

      })(Backbone.Collection);
    });
    describe('when offline', function() {
      describe('with no local store initialized for the model/collection', function() {
        beforeEach(function() {
          return this.model = new Model;
        });
        it('calls the error callback', function(done) {
          return this.model.fetch({
            errorStatus: 0,
            error: function() {
              return done();
            }
          });
        });
        it('fails the deferred promise');
        return it('triggers the error event', function(done) {
          this.model.on('error', function() {
            return done();
          });
          return this.model.fetch({
            errorStatus: 0
          });
        });
      });
      describe('with a local store initialized', function() {
        beforeEach(function(done) {
          this.model = new Model;
          return this.model.save(null, {
            errorStatus: 0,
            success: function() {
              return done();
            }
          });
        });
        it('calls the success callback', function(done) {
          return this.model.fetch({
            errorStatus: 0,
            success: function() {
              return done();
            }
          });
        });
        it('resolves the deferred promise');
        return it('triggers the sync event', function(done) {
          this.model.on('sync', function() {
            return done();
          });
          return this.model.fetch({
            errorStatus: 0
          });
        });
      });
      describe('when fetching an id that is not cached', function() {
        beforeEach(function(done) {
          var model;
          model = new Model({
            _id: 1
          });
          return model.save(null, {
            errorStatus: 0,
            success: function() {
              return done();
            }
          });
        });
        it('calls the error callback', function(done) {
          var model;
          model = new Model({
            _id: 999
          });
          return model.fetch({
            errorStatus: 0,
            error: function() {
              return done();
            }
          });
        });
        it('fails the deferred promise');
        return it('triggers the error event', function(done) {
          var model;
          model = new Model({
            _id: 999
          });
          model.on('error', function() {
            return done();
          });
          return model.fetch({
            errorStatus: 0
          });
        });
      });
      return describe('the dirty attribute', function() {
        beforeEach(function(done) {
          this.model = new Model;
          return this.model.save(null, {
            errorStatus: 0,
            success: function() {
              return done();
            }
          });
        });
        it('is set in the callback options', function(done) {
          return this.model.fetch({
            errorStatus: 0,
            success: function(model, reponse, options) {
              expect(options.dirty).to.be["true"];
              return done();
            }
          });
        });
        it('is set in the promise doneCallback options');
        return it('is set in the sync event options', function(done) {
          this.model.on('sync', function(model, response, options) {
            expect(options.dirty).to.be["true"];
            return done();
          });
          return this.model.fetch({
            errorStatus: 0
          });
        });
      });
    });
    return describe('when online', function() {
      describe('receiving an error response', function() {
        beforeEach(function() {
          return this.model = new Model;
        });
        it('calls the error callback', function(done) {
          return this.model.fetch({
            errorStatus: 500,
            error: function() {
              return done();
            }
          });
        });
        it('fails the deferred promise');
        return it('triggers the error event', function(done) {
          this.model.on('error', function() {
            return done();
          });
          return this.model.fetch({
            errorStatus: 500
          });
        });
      });
      describe('receiving a successful response', function() {
        beforeEach(function() {
          return this.model = new Model({
            _id: 1
          });
        });
        it('calls the success callback', function(done) {
          return this.model.fetch({
            success: function() {
              return done();
            }
          });
        });
        it('resolves the deferred promise');
        return it('triggers the sync event', function(done) {
          this.model.on('sync', function() {
            return done();
          });
          return this.model.fetch();
        });
      });
      return describe('the dirty attribute', function() {
        beforeEach(function(done) {
          this.model = new Model;
          return this.model.save('_id', '1', {
            success: function() {
              return done();
            }
          });
        });
        it('is set in the callback options', function(done) {
          return this.model.fetch({
            success: function(model, reponse, options) {
              expect(options.dirty).not.to.be["true"];
              return done();
            }
          });
        });
        it('is set in the promise doneCallback options');
        return it('is set in the sync event options', function(done) {
          this.model.on('sync', function(model, response, options) {
            expect(options.dirty).not.to.be["true"];
            return done();
          });
          return this.model.fetch();
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=callbacks_spec.js.map
